# Контракт фоновых задач

## Жизненный цикл
| Этап | Описание |
| --- | --- |
| request | HTTP-запрос проходит валидацию и авторизацию; подготавливаются параметры задачи и ключ |
| enqueue | `Job(key, handler)` добавляется в очередь, если статус по ключу не `queued/running/succeeded` |
| execute | Worker (`default_job_runner`) выполняет `handler` в отдельной сессии БД |
| retry | До `max_attempts` (по умолчанию 3) с задержкой `backoff_seconds * min(attempt, max_attempts)`, где `attempt` — номер повторной попытки начиная с 1 |
| done | Статус `succeeded` или `failed` сохраняется в памяти; при рестарте очищается |

## Допустимо
- Исполнение уже проверенной операции (добавление/удаление избранного, запись прогресса и т.п.) в отдельной транзакции.
- Использование детерминированного ключа (`favorite:add:<user_id>:<anime_id>` и т.д.) для идемпотентности и дедупликации.
- Логирование ошибок без скрытия исключений внутри worker-а.

## Запрещено
- Блокировать или изменять исходный HTTP-ответ: результат запроса не зависит от успешности фоновой задачи.
- Менять аутентификацию/RBAC, выдавать токены, выполнять побочные эффекты вне контролируемых операций с БД.
- Полагаться на состояние процесса: очередь in-memory, данные исчезают после рестарта, поэтому задачи должны быть самодостаточными.

## Идемпотентность и ключи
- Каждый тип задачи обязан иметь предсказуемый ключ, чтобы повторный enqueue не создавал дубликаты.
- `handler` должен быть устойчив к повторному выполнению под тем же ключом (предварительные проверки/упсерт).

## Политика повторов и ошибки
- Попытки: до 3; после каждой неудачи счётчик `attempts` увеличивается, задержка = `backoff_seconds * min(attempts, max_attempts)` (при `backoff_seconds=1` это 1s → 2s → 3s). Backoff линейный, а не экспоненциальный.
- При исчерпании попыток статус `failed`; ошибка фиксируется в логах, но не отправляется клиенту.
- Ошибка фоновой задачи **не** меняет ответ уже выданного HTTP-запроса; мониторинг/алерты должны строиться отдельно.

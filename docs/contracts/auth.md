# Контракт аутентификации

## Эндпоинты и ответы
| Метод | Путь | Тело запроса | Успех | Ошибки |
| --- | --- | --- | --- | --- |
| POST | /auth/register | `email`, `password` (>=8) | 201 + `{access_token, refresh_token, token_type="bearer"}` | 400 при уже существующем email, 500 при внутренней ошибке |
| POST | /auth/login | `email`, `password` | 200 + `{access_token, refresh_token, token_type="bearer"}` | 401 при неверных учётных данных, 500 при внутренней ошибке |
| POST | /auth/refresh | `refresh_token` | 200 + новый `{access_token, refresh_token, token_type="bearer"}`; старый refresh заменяется | 401 при неизвестном/просроченном refresh, 403 при отозванном refresh |
| POST | /auth/logout | `refresh_token` | 204, refresh помечается как `revoked` (идемпотентно, 204 даже при отсутствии токена) | 500 при внутренней ошибке |

## Токены, cookies и заголовки
- Сервер **не** устанавливает cookies и не читает их: токены приходят только в теле ответа. Поля HttpOnly / Secure / SameSite неприменимы.
- Access token добавляется фронтендом в заголовок `Authorization: Bearer <token>` для всех запросов, требующих аутентификации.
- Срок жизни access token по умолчанию 30 минут, refresh token — 14 дней (конфиг `ACCESS_TOKEN_EXPIRE_MINUTES`, `REFRESH_TOKEN_EXPIRE_DAYS`).
- Поле `token_type` в ответах всегда в нижнем регистре (`"bearer"`), тогда как заголовок `Authorization` использует схему `Bearer` с заглавной буквой.
- Refresh токен хранится в БД в виде хеша; при каждом `/auth/refresh` значение поворачивается (старый считается недействительным).

## Сценарии и коды
- **Успешный логин/регистрация**: фронт сохраняет оба токена, выставляет `Authorization` для последующих запросов.
- **Истёкший access token**: сервер возвращает 401 (`Token has expired`). Фронт один раз вызывает `/auth/refresh`; при 401/403 на refresh — очищает хранилище и возвращает пользователя к неавторизованному состоянию.
- **Отозванный refresh** (logout уже выполнен): `/auth/refresh` отвечает 403. Фронт обязан удалить локальные токены и не повторять refresh.
- **Logout**: фронт отправляет `refresh_token`, не ждёт тела ответа и всегда локально очищает сессию, так как сервер отвечает 204 даже при отсутствии записи.

## Что должен делать фронтенд
- Хранить `access_token` и `refresh_token` в собственном хранилище (persisted state/localStorage) и прикреплять access token к вызовам, где он нужен.
- Обрабатывать 401/403 согласно сценариям выше (очистка сессии, единичный refresh-поток).
- Не посылать запросы, требующие авторизации, без заголовка `Authorization`.

## Что фронтенд не решает
- Не пытается валидировать или продлевать токены локально; единственный источник истины — ответы `/auth/refresh` и данные БД.
- Не обходит 403 (RBAC/отзыв refresh) дополнительными попытками.
- Не кладёт токены в cookies и не полагается на автоматическую отправку браузером; передача всегда явная через заголовки или тело запроса для refresh/logout.
